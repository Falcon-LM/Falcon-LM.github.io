<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><script>!function(e,t){if(!e.rdt){var s,o,n=e.rdt=function(){n.sendEvent?n.sendEvent.apply(n,arguments):n.callQueue.push(arguments)};n.callQueue=[],s=t.createElement("script"),s.src="https://www.redditstatic.com/ads/pixel.js",s.async=!0,o=t.getElementsByTagName("script")[0],o.parentNode.insertBefore(s,o)}}(window,document),rdt("init","a2_f0we4sxffrnm"),rdt("track","PageVisit")</script><script async src="https://www.googletagmanager.com/gtag/js?id=AW-16575356988"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","AW-16575356988")</script><title>Falcon-H1 Local Deployment Guide: MLX, llama.cpp, and OpenWebUI | Falcon</title>
<meta name=keywords content><meta name=description content="
Overview
Sometimes your projects are about more than quick answers. You might need to read through hundreds of pages, keep a long conversation going, or work in multiple languages. Falcon H1 was designed for exactly that. By combining Transformer-based attention with State Space Models (SSM), it understands complex information while still running efficiently on everyday hardware."><meta name=author content="Falcon Team"><link rel=canonical href=https://falcon-lm.github.io/tutorials/falcon-h1/><link crossorigin=anonymous href=/assets/css/stylesheet.8b9fa41d05770f933657a6befdf3e59416a8572dcdccb2def3ee65a2976037d3.css integrity="sha256-i5+kHQV3D5M2V6a+/fPllBaoVy3NzLLe8+5lopdgN9M=" rel="preload stylesheet" as=style><link rel=icon href=https://falcon-lm.github.io/img/favicon.png><link rel=apple-touch-icon href=https://falcon-lm.github.io/img/favicon.png><link rel=manifest href=https://falcon-lm.github.io/site.webmanifest><meta name=theme-color content="#615CED"><link rel=alternate hreflang=en href=https://falcon-lm.github.io/tutorials/falcon-h1/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script defer crossorigin=anonymous src=/js/custom.c0c4976150cc57e4e574f010d054d68896d28645b524650723d1cbb26891c0a3.js integrity="sha256-wMSXYVDMV+TldPAQ0FTWiJbShkW1JGUHI9HLsmiRwKM="></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.3/dist/katex.min.css integrity=sha384-Juol1FqnotbkyZUT5Z7gUPjQ9gzlwCENvUZTpQBAPxtusdwFLRy382PSDx5UUJ4/ crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.3/dist/katex.min.js integrity=sha384-97gW6UIJxnlKemYavrqDHSX3SiygeOwIZhwyOKRfSaf0JWKRVj9hLASHgFTzT+0O crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.3/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-5PVYBMYHS6"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-5PVYBMYHS6")}</script><meta property="og:title" content="Falcon-H1 Local Deployment Guide: MLX, llama.cpp, and OpenWebUI"><meta property="og:description" content="
Overview
Sometimes your projects are about more than quick answers. You might need to read through hundreds of pages, keep a long conversation going, or work in multiple languages. Falcon H1 was designed for exactly that. By combining Transformer-based attention with State Space Models (SSM), it understands complex information while still running efficiently on everyday hardware."><meta property="og:type" content="article"><meta property="og:url" content="https://falcon-lm.github.io/tutorials/falcon-h1/"><meta property="og:image" content="https://falcon-lm.github.io/tutorials/falcon-h1/images/falcon-h1-logo.png"><meta property="article:section" content="tutorials"><meta property="article:published_time" content="2025-02-24T12:00:00+00:00"><meta property="article:modified_time" content="2025-02-24T12:00:00+00:00"><meta property="og:site_name" content="Falcon"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://falcon-lm.github.io/tutorials/falcon-h1/images/falcon-h1-logo.png"><meta name=twitter:title content="Falcon-H1 Local Deployment Guide: MLX, llama.cpp, and OpenWebUI"><meta name=twitter:description content="
Overview
Sometimes your projects are about more than quick answers. You might need to read through hundreds of pages, keep a long conversation going, or work in multiple languages. Falcon H1 was designed for exactly that. By combining Transformer-based attention with State Space Models (SSM), it understands complex information while still running efficiently on everyday hardware."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Tutorials","item":"https://falcon-lm.github.io/tutorials/"},{"@type":"ListItem","position":2,"name":"Falcon-H1 Local Deployment Guide: MLX, llama.cpp, and OpenWebUI","item":"https://falcon-lm.github.io/tutorials/falcon-h1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Falcon-H1 Local Deployment Guide: MLX, llama.cpp, and OpenWebUI","name":"Falcon-H1 Local Deployment Guide: MLX, llama.cpp, and OpenWebUI","description":" Overview Sometimes your projects are about more than quick answers. You might need to read through hundreds of pages, keep a long conversation going, or work in multiple languages. Falcon H1 was designed for exactly that. By combining Transformer-based attention with State Space Models (SSM), it understands complex information while still running efficiently on everyday hardware.\n","keywords":[],"articleBody":" Overview Sometimes your projects are about more than quick answers. You might need to read through hundreds of pages, keep a long conversation going, or work in multiple languages. Falcon H1 was designed for exactly that. By combining Transformer-based attention with State Space Models (SSM), it understands complex information while still running efficiently on everyday hardware.\nWhat makes Falcon H1 stand out\nHybrid architecture mixing Transformer and SSM. Can handle up to 256K context tokens, perfect for huge reports or long meetings. Multilingual capability: Supports many languages for diverse applications, including Arabic (ar), Czech (cs), German (de), English (en), Spanish (es), French (fr), Hindi (hi), Italian (it), Japanese (ja), Korean (ko), Dutch (nl), Polish (pl), Portuguese (pt), Romanian (ro), Russian (ru), Swedish (sv), Urdu (ur), and Chinese (zh). Runs smoothly on consumer grade GPUs, CPUs, and Apple Silicon devices. How to get started Falcon H1 can be deployed using MLX for Apple Silicon or llama.cpp in gguf format for other laptops. When paired with OpenWebUI, it provides a clean conversational workspace that functions like a multilingual AI colleague. This guide will walk you through the detailed steps for implementation.\nLearn more:\nFalcon H1 Release Blog Post Falcon H1 Paper Mamba Paper Mamba2 Paper MLX Framework Overview llama.cpp Github Repository Open-Web UI Model Variants The Falcon H1 series comprises open-source large language models engineered for adaptability across a wide spectrum of hardware environments. This suite is available in six distinct model sizes, such as 0.5B, 1.5B, 1.5B Deep, 3B, 7B, and 34B, each offered in both base and instruct configurations. All variants are distributed under the permissive Falcon-LLM license.\nThe smaller-scale configurations, namely 0.5B, 1.5B, and 1.5B Deep, are particularly well-suited for on-device deployment on personal computers, laptops, and other compact hardware platforms. These models provide optimized resource consumption, low inference latency, and strong compatibility with consumer-grade GPUs, CPUs, and Apple Silicon architectures, while retaining Falcon H1 features like extended context processing and multilingual functionality. Conversely, the larger configurations, such as 3B, 7B, and 34B, deliver superior computational performance, albeit necessitating higher-performance infrastructure. The complete range of available versions can be explored on Hugging Face.\nThe collection also includes GGUF formats, for further information on the gguf quantization formats, please refer to Hugging Face GGUF Quantization Types\nPrerequisites Before configuring Falcon H1 on your system, it is essential to verify that the local environment satisfies the minimum specifications necessary for efficient model execution.\nOperating Systems Linux: Recommended for llama.cpp with full CPU/GPU support. macOS: Supported via MLX and llama.cpp, with GPU acceleration through Metal, optimized for Apple Silicon. Windows: Supports llama.cpp with CPU execution; GPU acceleration is available through CUDA for compatible NVIDIA graphics cards. Python Utilize a virtual environment such as conda to manage dependencies. While llama.cpp operates natively without Python, optional Python bindings are available through the llama-cpp-python package. Hugging Face Account Active account required: Hugging Face A free account meets most needs. Installation The installation section is identical as the one from Falcon3 tutorial - in case you went through already on the previous tutorial, you can directly move to the download section\nDownload Model Weights from Hugging Face With the environment set up and all necessary tools and dependencies installed, the next step is to download a compact LLM to your laptop. You can get the Falcon H1 0.5B and 1.5B models from the official Hugging Face repository maintained by TII. This guide focuses on the Falcon 1.5B Instruct model.\nThe Hugging Face collection offers complete model weights in multiple formats, including .safetensors and .gguf. The default format for storing model weights is .safetensors. Keep in mind that llama.cpp can serve models only in the .gguf format, while the MLX framework supports both .gguf and .safetensors.\nNote: Currently, TII provides ready-to-use .gguf and quantized model versions on their official Hugging Face repository. This means you can directly download the model weights to your local machine for use. When working with the llama.cpp framework, you’ll need a .gguf model as mentioned above. Make sure to choose a version that matches your hardware’s minimum requirements. In this example, we’ll experiment with the Falcon 1.5B Instruct .gguf model. If you’re using the mlx framework, you’ll be working with quantized versions. For the same 1.5B model size, you can select quantized versions in 4, 6, or 8-bit formats based on your hardware capabilities. Here, we’ll try the 1.5B 4-bit version.\nTo download the model weights, we’ll use the hf CLI tool. Ensure that you have it installed on your laptop and that you’re logged in with your Hugging Face account. To verify your installation and authentication, run:\nhf auth whoami If the installation or authentication hasn’t been completed, follow the instructions provided in huggingface link.\nNow, let’s download the .gguf model version by running the following command:\nhf download tiiuae/Falcon-H1-1.5B-Instruct-GGUF Falcon-H1-1.5B-Instruct-Q4_K_M.gguf --local-dir Falcon-H1-1.5B-Instruct-GGUF Note: Multiple quantized versions are available, so choose one that matches your hardware capabilities.\nNext, we’ll download the 4-bit quantized model version with this command:\nhf download mlx-community/Falcon-H1-1.5B-Instruct-4bit --local-dir Falcon-H1-1.5B-Instruct-4bit Note: This script will download the entire Hugging Face repository to your local machine.\nBy default, downloaded models are saved to Hugging Face’s ~/.cache/huggingface/hub folder. However, if you prefer to specify a custom storage location, you can use the --local-dir tag and provide the exact folder path where you want the model saved. Once the downloads are complete, navigate to the folder where you saved the model weights to verify them. You should see output similar to the example shown below:\n.gguf model .safetensors quantized model Serving Falcon-H1 The environment and all requirements for running the model are now fully set up. Next, we’ll walk through the steps for using each framework to serve LLMs directly on your system. We will start with deploying the LLM using the llama.cpp framework.\nRunning the llama.cpp Server First, make sure the server starts successfully and that it is running as expected.\nTo confirm the binary works, run:\nllama-server --help This will display a list of available options. Some will be explained here, while others you can explore on your own. For now, the key options to note are:\n-m, --model FNAME: Path to the model (default: models/$filename taken from --hf-file or --model-url if set, otherwise models/7B/ggml-model-f16.gguf). Environment variable: LLAMA_ARG_MODEL. --host HOST: IP address for the server to listen on (default: 127.0.0.1). Environment variable: LLAMA_ARG_HOST. --port PORT: Port for the server to listen on (default: 8080). Environment variable: LLAMA_ARG_PORT. To run the server with a quantized Falcon-H1 GGUF model, execute:\nllama-server -m ./Falcon-H1-1.5B-Instruct-GGUF/Falcon-H1-1.5B-Instruct-Q4_K_M.gguf You should see similar output after running this command:\nIf nothing else is running on 127.0.0.1:8080, the default host and port can be kept. You can also use environment variables instead of command-line arguments for convenience.\nWhen the server starts, it will expose a local OpenAI-compatible API at:\nhttp://127.0.0.1:8080 Server Settings in llama.cpp The llama-server includes a Web UI accessible via the API above. It shows a small set of configuration options focused on LLM sampling. For the full list, run:\nllama-server --help These options can affect both how your model behaves and the speed of text generation. Many of them can be set via environment variables, which are consistent across other llama.cpp executables.\nClick to view key general parameters --threads/--threads-batch (LLAMA_ARG_THREADS): Number of CPU threads to use. Default -1 automatically detects available cores. --ctx-size (LLAMA_ARG_CTX_SIZE): The model’s context size (how many tokens it can remember). Larger sizes require more memory. --predict (LLAMA_ARG_N_PREDICT): Maximum tokens to generate. Default -1 means continuous generation. --batch-size/--ubatch-size (LLAMA_ARG_BATCH/LLAMA_ARG_UBATCH): Number of tokens processed per step. --flash-attn (LLAMA_ARG_FLASH_ATTN): Enables flash attention optimization for supported models. --mlock (LLAMA_ARG_MLOCK): Keeps the model in memory to avoid swapping. --no-mmap (LLAMA_ARG_NO_MMAP): Disables memory mapping. --gpu-layers (LLAMA_ARG_N_GPU_LAYERS): Number of layers to offload to the GPU (requires GPU-enabled build). Click to view server-specific parameters --no-context-shift (LLAMA_ARG_NO_CONTEXT_SHIFT): Stops generation when the context is full instead of discarding old tokens. --cont-batching (LLAMA_ARG_CONT_BATCHING): Allows prompts to be processed in parallel with generation. --alias (LLAMA_ARG_ALIAS): Sets a model name alias for the REST API. --slots (LLAMA_ARG_ENDPOINT_SLOTS): Enables the /slots endpoint. --props (LLAMA_ARG_ENDPOINT_PROPS): Enables the /props endpoint. Deployment with the MLX Framework on macOS You now know how to serve the model on your laptop using llama.cpp. Next, I’ll show you how to use the MLX framework in case you have a MacBook. Another option for serving LLMs is the MLX framework, which is built specifically for macOS and optimized for Apple hardware.\nRunning the MLX Server Start the server with:\nmlx_lm.server --model ./Falcon-H1-1.5B-Instruct-4bit You should see similar output after running this command:\nThis starts a text generation service on localhost:8080 using the Falcon H1 1.5B Instruct model. If the model is not already in your local cache, it will be downloaded from the specified Hugging Face repository. However, I recommend downloading the model to your local system first, as described earlier.\nTo see all available options, run:\nmlx_lm.server --help To make a request to the model:\ncurl localhost:8080/v1/chat/completions \\ -H \"Content-Type: application/json\" \\ -d '{ \"messages\": [{\"role\": \"user\", \"content\": \"Hello\"}], \"temperature\": 0.7 }' Request Fields Click to view all request fields messages: List of message objects with role and content. role_mapping: Optional dictionary to customize role prefixes. stop: Optional stop sequences. max_tokens: Maximum tokens to generate (default: 512). stream: Boolean to stream responses (default: false). temperature: Controls randomness (default: 0.0). top_p: Nucleus sampling parameter (default: 1.0). top_k: Top-K sampling parameter (default: 0). min_p: Minimum probability sampling parameter (default: 0.0). repetition_penalty: Penalty for repeated tokens (default: 1.0). repetition_context_size: Context size for applying repetition penalty (default: 20). logit_bias: Mapping of token IDs to bias values. logprobs: Number of top token probabilities to return (1–10). model: Path or Hugging Face repo for the model. adapters: Path to low-rank adapters. draft_model: Smaller model for speculative decoding. num_draft_tokens: Draft tokens predicted at once (default: 3). Response Fields Click to view all response fields id: Unique chat ID. system_fingerprint: System identifier. object: Response type (chat.completion, chat.completion.chunk, or text.completion). model: Model path or repo name. created: Timestamp of request. choices: Output list with index, optional log probabilities, finish reason, and message text. usage: Token statistics: prompt, completion, and total tokens. If nothing else is running on 127.0.0.1:8080, you can keep the default host and port. For convenience, environment variables can be used instead of command-line arguments.\nOnce the server starts, it will expose a local OpenAI-compatible API at:\nhttp://127.0.0.1:8080 Congratulations! If you’ve chosen the Falcon H1R model, you have now successfully served it on your laptop and it’s ready to use. Next, let’s look at integrating the model into OpenWebUI for chatting.\nIntegrating with OpenwebUI Once your selected serving framework is running, the next step is to connect Falcon-H1 to Open WebUI, giving you a simple chat-based interface for interacting with the model.\nStarting Open WebUI First, let’s proceed with installing open-webui cli. Use the command below to install:\npip install open-webui Note: You should install open-webui cli within your existing conda virtual environment. If you are using MLX to serve local llm and already have a conda environment set up, install open-webui cli in that same one. Then activate your environment to proceed.\nAfter successful installation, let’s launch the server.\nopen-webui serve Default access: http://localhost:8080 Custom port: open-webui serve --port 3000 --host 0.0.0.0 Connecting llama.cpp to Open WebUI Open Open WebUI in your browser. Navigate to Admin Settings → Connections → OpenAI. Click Add Connection. Under Standard / Compatible (if tabs are visible), configure the following: URL: http://127.0.0.1:8080/v1. API Key: Leave blank or enter a specific key if configured. Once the connection is saved, Open WebUI will use your local llama.cpp server or mlx server as its backend.\nAlright, let’s head back to the main screen and try out a few questions to test the model’s intelligence.\nCongratulations — you now have your very own chatbot powered by the Falcon models running right on your laptop.\nConclusion This guide has outlined the process of deploying Falcon-H1 locally using either the MLX framework for macOS-optimized workflows or the llama.cpp framework for GGUF model formats, along with integrating the chosen backend into Open WebUI to provide an interactive chat interface. The topics covered include minimum system requirements, environment setup, downloading model weights, server configuration, integration steps, and key considerations before deployment.\nFollowing these steps allows Falcon-H1 to be deployed in a way that matches your hardware capabilities and performance goals, ensuring both efficiency and ease of use. The MLX framework delivers smooth integration with Apple’s hardware ecosystem, while llama.cpp offers portability and compatibility with GGUF models, giving you flexible options for various AI applications.\nFor additional experimentation, you can explore other Falcon-H1 variants available on Hugging Face, apply performance optimizations, or incorporate the model into custom workflows and interfaces. With the right setup, Falcon-H1 can be a powerful and versatile asset in your local AI development environment.\n","wordCount":"2124","inLanguage":"en","image":"https://falcon-lm.github.io/tutorials/falcon-h1/images/falcon-h1-logo.png","datePublished":"2025-02-24T12:00:00Z","dateModified":"2025-02-24T12:00:00Z","author":{"@type":"Person","name":"Falcon Team"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://falcon-lm.github.io/tutorials/falcon-h1/"},"publisher":{"@type":"Organization","name":"Falcon","logo":{"@type":"ImageObject","url":"https://falcon-lm.github.io/img/favicon.png"}}}</script></head><body id=top><script>const hasHeaderBg=!0</script><header class=header><div class="nav-container nav-background"><nav class=nav><div class=logo><a href=/ accesskey=h title="Falcon (Alt + H)"><img src=https://falcon-lm.github.io/img/logo.svg alt aria-label=logo height=30></a></div><ul id=menu><li><a href=/blog/ title=Blog><span>Blog</span></a></li><li><a href=/tutorials/ title=Tutorials><span>Tutorials</span></a></li><li><a href=/publication title=Publication><span>Publication</span></a></li><li><a href=/about title=About><span>About</span></a></li><li><a href=https://chat.falconllm.tii.ae/ title="Try Falcon Chat"><span>Try Falcon Chat</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></div></header><div class=hero-container><div class=hero-background style="background:url(./images/falcon-h1-logo.png)50%/cover no-repeat fixed"></div><div class=hero-gradient></div><div class=hero-blur></div><div class="hero text-light"><h1 class=post-title>Falcon-H1 Local Deployment Guide: MLX, llama.cpp, and OpenWebUI</h1><div class=post-meta><span title='2025-02-24 12:00:00 +0000 UTC'>February 24, 2025</span>&nbsp;•&nbsp;Falcon Team</div></div></div><main class=main><article class=post-single><figure class=entry-cover><a href=./images/falcon-h1-logo.png target=_blank rel="noopener noreferrer"><img loading=lazy src=./images/falcon-h1-logo.png alt></a></figure><div class=post-content><style>table{border-collapse:collapse;width:100%;background-color:transparent;border-radius:8px;overflow:hidden;color:inherit}th,td{padding:12px 16px;border:1px solid;border-color:rgba(0,0,0,.3)}@media(prefers-color-scheme:dark){th,td{border-color:rgba(255,255,255,.2)}tr:nth-child(even) td{background-color:rgba(255,255,255,5%)}tr:hover td{background-color:rgba(255,255,255,.1)}}@media(prefers-color-scheme:light){tr:nth-child(even) td{background-color:rgba(0,0,0,5%)}tr:hover td{background-color:rgba(0,0,0,.1)}}th{font-weight:700}blockquote{border-left:4px solid rgba(128,128,128,.4);margin:1em 0;padding:.5em 1em;background-color:transparent;color:inherit;font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,helvetica neue,Arial,sans-serif;font-size:.9em;font-style:italic}blockquote p{margin:0}blockquote p strong{font-weight:700;font-style:italic}blockquote p::before{content:"“"}blockquote p::after{content:"”"}ul+p strong:first-child,ul+p:has(strong:first-child){display:block;margin-top:1.5em;margin-bottom:.5em}p strong:only-child{display:inline-block;margin-top:1em;margin-bottom:.5em}</style><h2 id=overview>Overview<a hidden class=anchor aria-hidden=true href=#overview>#</a></h2><p>Sometimes your projects are about more than quick answers. You might need to read through hundreds of pages, keep a long conversation going, or work in multiple languages. Falcon H1 was designed for exactly that. By combining Transformer-based attention with State Space Models (SSM), it understands complex information while still running efficiently on everyday hardware.</p><p><strong>What makes Falcon H1 stand out</strong></p><ul><li>Hybrid architecture mixing Transformer and SSM.</li><li>Can handle up to 256K context tokens, perfect for huge reports or long meetings.</li><li>Multilingual capability: Supports many languages for diverse applications, including Arabic (ar), Czech (cs), German (de), English (en), Spanish (es), French (fr), Hindi (hi), Italian (it), Japanese (ja), Korean (ko), Dutch (nl), Polish (pl), Portuguese (pt), Romanian (ro), Russian (ru), Swedish (sv), Urdu (ur), and Chinese (zh).</li><li>Runs smoothly on consumer grade GPUs, CPUs, and Apple Silicon devices.</li></ul><p><strong>How to get started</strong>
Falcon H1 can be deployed using MLX for Apple Silicon or llama.cpp in gguf format for other laptops. When paired with OpenWebUI, it provides a clean conversational workspace that functions like a multilingual AI colleague. This guide will walk you through the detailed steps for implementation.</p><p>Learn more:</p><ul><li><a href=https://huggingface.co/blog/tiiuae/falcon-h1>Falcon H1 Release Blog Post</a></li><li><a href=https://arxiv.org/abs/2507.22448>Falcon H1 Paper</a></li><li><a href=https://arxiv.org/abs/2405.21060>Mamba Paper</a></li><li><a href=https://arxiv.org/abs/2312.00752>Mamba2 Paper</a></li><li><a href=https://mlx-framework.org/#features>MLX Framework Overview</a></li><li><a href=https://github.com/ggml-org/llama.cpp>llama.cpp Github Repository</a></li><li><a href=https://openwebui.com>Open-Web UI</a></li></ul><h2 id=model-variants>Model Variants<a hidden class=anchor aria-hidden=true href=#model-variants>#</a></h2><p>The Falcon H1 series comprises open-source large language models engineered for adaptability across a wide spectrum of hardware environments. This suite is available in six distinct model sizes, such as 0.5B, 1.5B, 1.5B Deep, 3B, 7B, and 34B, each offered in both base and instruct configurations. All variants are distributed under the permissive Falcon-LLM license.</p><p>The smaller-scale configurations, namely 0.5B, 1.5B, and 1.5B Deep, are particularly well-suited for on-device deployment on personal computers, laptops, and other compact hardware platforms. These models provide optimized resource consumption, low inference latency, and strong compatibility with consumer-grade GPUs, CPUs, and Apple Silicon architectures, while retaining Falcon H1 features like extended context processing and multilingual functionality. Conversely, the larger configurations, such as 3B, 7B, and 34B, deliver superior computational performance, albeit necessitating higher-performance infrastructure. The complete range of available versions can be explored on <a href=https://huggingface.co/collections/tiiuae/falcon-h1>Hugging Face</a>.</p><p>The collection also includes GGUF formats, for further information on the gguf quantization formats, please refer to <a href=https://huggingface.co/docs/hub/gguf#quantization-types>Hugging Face GGUF Quantization Types</a></p><h2 id=prerequisites>Prerequisites<a hidden class=anchor aria-hidden=true href=#prerequisites>#</a></h2><p>Before configuring Falcon H1 on your system, it is essential to verify that the local environment satisfies the minimum specifications necessary for efficient model execution.</p><h3 id=operating-systems>Operating Systems<a hidden class=anchor aria-hidden=true href=#operating-systems>#</a></h3><ul><li>Linux: Recommended for llama.cpp with full CPU/GPU support.</li><li>macOS: Supported via MLX and llama.cpp, with GPU acceleration through Metal, optimized for Apple Silicon.</li><li>Windows: Supports llama.cpp with CPU execution; GPU acceleration is available through CUDA for compatible NVIDIA graphics cards.</li></ul><h3 id=python>Python<a hidden class=anchor aria-hidden=true href=#python>#</a></h3><ul><li>Utilize a virtual environment such as conda to manage dependencies.</li><li>While llama.cpp operates natively without Python, optional Python bindings are available through the <a href=https://github.com/abetlen/llama-cpp-python>llama-cpp-python</a> package.</li></ul><h3 id=hugging-face-account>Hugging Face Account<a hidden class=anchor aria-hidden=true href=#hugging-face-account>#</a></h3><ul><li>Active account required: <a href=https://huggingface.co/>Hugging Face</a></li><li>A free account meets most needs.</li></ul><h2 id=installation>Installation<a hidden class=anchor aria-hidden=true href=#installation>#</a></h2><p>The installation section is identical as the one from <a href=http://localhost:1313/tutorials/falcon-3/>Falcon3 tutorial</a> - in case you went through already on the previous tutorial, you can directly move to the download section</p><h2 id=download-model-weights-from-hugging-face>Download Model Weights from Hugging Face<a hidden class=anchor aria-hidden=true href=#download-model-weights-from-hugging-face>#</a></h2><p>With the environment set up and all necessary tools and dependencies installed, the next step is to download a compact LLM to your laptop. You can get the Falcon H1 0.5B and 1.5B models from the official <a href=https://huggingface.co/collections/tiiuae/falcon-h1>Hugging Face</a> repository maintained by TII. This guide focuses on the <strong>Falcon 1.5B Instruct</strong> model.</p><p>The Hugging Face collection offers complete model weights in multiple formats, including <code>.safetensors</code> and <code>.gguf</code>. The default format for storing model weights is <code>.safetensors</code>. Keep in mind that <strong>llama.cpp</strong> can serve models only in the <code>.gguf</code> format, while the <strong>MLX</strong> framework supports both <code>.gguf</code> and <code>.safetensors</code>.</p><blockquote><p><strong>Note:</strong> Currently, TII provides ready-to-use .gguf and quantized model versions on their official Hugging Face repository. This means you can directly download the model weights to your local machine for use. When working with the llama.cpp framework, you’ll need a .gguf model as mentioned above. Make sure to choose a version that matches your hardware’s minimum requirements. In this example, we’ll experiment with the Falcon 1.5B Instruct .gguf model. If you’re using the mlx framework, you’ll be working with quantized versions. For the same 1.5B model size, you can select quantized versions in 4, 6, or 8-bit formats based on your hardware capabilities. Here, we’ll try the 1.5B 4-bit version.</p></blockquote><p>To download the model weights, we’ll use the <strong>hf</strong> CLI tool. Ensure that you have it installed on your laptop and that you’re logged in with your Hugging Face account. To verify your installation and authentication, run:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>hf auth whoami
</span></span></code></pre></div><p>If the installation or authentication hasn’t been completed, follow the instructions provided in <a href=https://huggingface.co/docs/huggingface_hub/guides/cli>huggingface link</a>.</p><p>Now, let’s download the .gguf model version by running the following command:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>hf download tiiuae/Falcon-H1-1.5B-Instruct-GGUF Falcon-H1-1.5B-Instruct-Q4_K_M.gguf --local-dir Falcon-H1-1.5B-Instruct-GGUF 
</span></span></code></pre></div><blockquote><p><strong>Note</strong>: Multiple quantized versions are available, so choose one that matches your hardware capabilities.</p></blockquote><p>Next, we’ll download the 4-bit quantized model version with this command:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>hf download mlx-community/Falcon-H1-1.5B-Instruct-4bit --local-dir Falcon-H1-1.5B-Instruct-4bit
</span></span></code></pre></div><blockquote><p><strong>Note:</strong> This script will download the entire Hugging Face repository to your local machine.</p></blockquote><p>By default, downloaded models are saved to Hugging Face’s <code>~/.cache/huggingface/hub</code> folder. However, if you prefer to specify a custom storage location, you can use the <code>--local-dir</code> tag and provide the exact folder path where you want the model saved. Once the downloads are complete, navigate to the folder where you saved the model weights to verify them. You should see output similar to the example shown below:</p><ul><li><code>.gguf</code> model</li></ul><img src=./images/model-gguf.png alt=Falcon-H1-1.5B-Instruct-GGUF style="width:100%;height:auto;border-radius:8px;box-shadow:0 4px 6px rgba(0,0,0,.1);display:block;margin:1.5em 0"><ul><li><code>.safetensors</code> quantized model</li></ul><img src=./images/model-4bit.png alt=Falcon-H1-1.5B-Instruct-4bit style="width:100%;height:auto;border-radius:8px;box-shadow:0 4px 6px rgba(0,0,0,.1);display:block;margin:1.5em 0"><h2 id=serving-falcon-h1>Serving Falcon-H1<a hidden class=anchor aria-hidden=true href=#serving-falcon-h1>#</a></h2><p>The environment and all requirements for running the model are now fully set up. Next, we’ll walk through the steps for using each framework to serve LLMs directly on your system.
We will start with deploying the LLM using the <strong>llama.cpp</strong> framework.</p><h3 id=running-the-llamacpp-server>Running the llama.cpp Server<a hidden class=anchor aria-hidden=true href=#running-the-llamacpp-server>#</a></h3><p>First, make sure the server starts successfully and that it is running as expected.<br>To confirm the binary works, run:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>llama-server --help
</span></span></code></pre></div><p>This will display a list of available options. Some will be explained here, while others you can explore on your own. For now, the key options to note are:</p><ul><li><code>-m, --model FNAME</code>: Path to the model (default: <code>models/$filename</code> taken from <code>--hf-file</code> or <code>--model-url</code> if set, otherwise <code>models/7B/ggml-model-f16.gguf</code>). Environment variable: <code>LLAMA_ARG_MODEL</code>.</li><li><code>--host HOST</code>: IP address for the server to listen on (default: <code>127.0.0.1</code>). Environment variable: <code>LLAMA_ARG_HOST</code>.</li><li><code>--port PORT</code>: Port for the server to listen on (default: <code>8080</code>). Environment variable: <code>LLAMA_ARG_PORT</code>.</li></ul><p>To run the server with a quantized Falcon-H1 GGUF model, execute:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>llama-server -m ./Falcon-H1-1.5B-Instruct-GGUF/Falcon-H1-1.5B-Instruct-Q4_K_M.gguf
</span></span></code></pre></div><p>You should see similar output after running this command:</p><img src=./images/llama-server.png alt=llama-server-output style="width:100%;height:auto;border-radius:8px;box-shadow:0 4px 6px rgba(0,0,0,.1);display:block;margin:1.5em 0"><p>If nothing else is running on <code>127.0.0.1:8080</code>, the default host and port can be kept. You can also use environment variables instead of command-line arguments for convenience.<br>When the server starts, it will expose a local OpenAI-compatible API at:</p><pre tabindex=0><code>http://127.0.0.1:8080
</code></pre><h3 id=server-settings-in-llamacpp>Server Settings in llama.cpp<a hidden class=anchor aria-hidden=true href=#server-settings-in-llamacpp>#</a></h3><p>The <code>llama-server</code> includes a Web UI accessible via the API above. It shows a small set of configuration options focused on LLM sampling. For the full list, run:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>llama-server --help
</span></span></code></pre></div><p>These options can affect both how your model behaves and the speed of text generation. Many of them can be set via environment variables, which are consistent across other llama.cpp executables.</p><details><summary><strong>Click to view key general parameters</strong></summary><ul><li><code>--threads/--threads-batch (LLAMA_ARG_THREADS)</code>: Number of CPU threads to use. Default <code>-1</code> automatically detects available cores.</li><li><code>--ctx-size (LLAMA_ARG_CTX_SIZE)</code>: The model’s context size (how many tokens it can remember). Larger sizes require more memory.</li><li><code>--predict (LLAMA_ARG_N_PREDICT)</code>: Maximum tokens to generate. Default <code>-1</code> means continuous generation.</li><li><code>--batch-size/--ubatch-size (LLAMA_ARG_BATCH/LLAMA_ARG_UBATCH)</code>: Number of tokens processed per step.</li><li><code>--flash-attn (LLAMA_ARG_FLASH_ATTN)</code>: Enables flash attention optimization for supported models.</li><li><code>--mlock (LLAMA_ARG_MLOCK)</code>: Keeps the model in memory to avoid swapping.</li><li><code>--no-mmap (LLAMA_ARG_NO_MMAP)</code>: Disables memory mapping.</li><li><code>--gpu-layers (LLAMA_ARG_N_GPU_LAYERS)</code>: Number of layers to offload to the GPU (requires GPU-enabled build).</li></ul></details><details><summary><strong>Click to view server-specific parameters</strong></summary><ul><li><code>--no-context-shift (LLAMA_ARG_NO_CONTEXT_SHIFT)</code>: Stops generation when the context is full instead of discarding old tokens.</li><li><code>--cont-batching (LLAMA_ARG_CONT_BATCHING)</code>: Allows prompts to be processed in parallel with generation.</li><li><code>--alias (LLAMA_ARG_ALIAS)</code>: Sets a model name alias for the REST API.</li><li><code>--slots (LLAMA_ARG_ENDPOINT_SLOTS)</code>: Enables the <code>/slots</code> endpoint.</li><li><code>--props (LLAMA_ARG_ENDPOINT_PROPS)</code>: Enables the <code>/props</code> endpoint.</li></ul></details><h3 id=deployment-with-the-mlx-framework-on-macos>Deployment with the MLX Framework on macOS<a hidden class=anchor aria-hidden=true href=#deployment-with-the-mlx-framework-on-macos>#</a></h3><p>You now know how to serve the model on your laptop using llama.cpp. Next, I’ll show you how to use the MLX framework in case you have a MacBook. Another option for serving LLMs is the <strong>MLX</strong> framework, which is built specifically for macOS and optimized for Apple hardware.</p><h3 id=running-the-mlx-server>Running the MLX Server<a hidden class=anchor aria-hidden=true href=#running-the-mlx-server>#</a></h3><p>Start the server with:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>mlx_lm.server --model ./Falcon-H1-1.5B-Instruct-4bit
</span></span></code></pre></div><p>You should see similar output after running this command:</p><img src=./images/mlx-server.png alt=mlx-lm-server-output style="width:100%;height:auto;border-radius:8px;box-shadow:0 4px 6px rgba(0,0,0,.1);display:block;margin:1.5em 0"><p>This starts a text generation service on <code>localhost:8080</code> using the Falcon H1 1.5B Instruct model. If the model is not already in your local cache, it will be downloaded from the specified Hugging Face repository. However, I recommend downloading the model to your local system first, as described earlier.</p><p>To see all available options, run:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>mlx_lm.server --help
</span></span></code></pre></div><p>To make a request to the model:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>curl localhost:8080/v1/chat/completions <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  -H <span class=s2>&#34;Content-Type: application/json&#34;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  -d <span class=s1>&#39;{
</span></span></span><span class=line><span class=cl><span class=s1>     &#34;messages&#34;: [{&#34;role&#34;: &#34;user&#34;, &#34;content&#34;: &#34;Hello&#34;}],
</span></span></span><span class=line><span class=cl><span class=s1>     &#34;temperature&#34;: 0.7
</span></span></span><span class=line><span class=cl><span class=s1>   }&#39;</span>
</span></span></code></pre></div><h3 id=request-fields>Request Fields<a hidden class=anchor aria-hidden=true href=#request-fields>#</a></h3><details><summary><strong>Click to view all request fields</strong></summary><ul><li><code>messages</code>: List of message objects with role and content.</li><li><code>role_mapping</code>: Optional dictionary to customize role prefixes.</li><li><code>stop</code>: Optional stop sequences.</li><li><code>max_tokens</code>: Maximum tokens to generate (default: 512).</li><li><code>stream</code>: Boolean to stream responses (default: <code>false</code>).</li><li><code>temperature</code>: Controls randomness (default: 0.0).</li><li><code>top_p</code>: Nucleus sampling parameter (default: 1.0).</li><li><code>top_k</code>: Top-K sampling parameter (default: 0).</li><li><code>min_p</code>: Minimum probability sampling parameter (default: 0.0).</li><li><code>repetition_penalty</code>: Penalty for repeated tokens (default: 1.0).</li><li><code>repetition_context_size</code>: Context size for applying repetition penalty (default: 20).</li><li><code>logit_bias</code>: Mapping of token IDs to bias values.</li><li><code>logprobs</code>: Number of top token probabilities to return (1–10).</li><li><code>model</code>: Path or Hugging Face repo for the model.</li><li><code>adapters</code>: Path to low-rank adapters.</li><li><code>draft_model</code>: Smaller model for speculative decoding.</li><li><code>num_draft_tokens</code>: Draft tokens predicted at once (default: 3).</li></ul></details><h3 id=response-fields>Response Fields<a hidden class=anchor aria-hidden=true href=#response-fields>#</a></h3><details><summary><strong>Click to view all response fields</strong></summary><ul><li><code>id</code>: Unique chat ID.</li><li><code>system_fingerprint</code>: System identifier.</li><li><code>object</code>: Response type (<code>chat.completion</code>, <code>chat.completion.chunk</code>, or <code>text.completion</code>).</li><li><code>model</code>: Model path or repo name.</li><li><code>created</code>: Timestamp of request.</li><li><code>choices</code>: Output list with index, optional log probabilities, finish reason, and message text.</li><li><code>usage</code>: Token statistics: prompt, completion, and total tokens.</li></ul></details><p>If nothing else is running on <code>127.0.0.1:8080</code>, you can keep the default host and port. For convenience, environment variables can be used instead of command-line arguments.<br>Once the server starts, it will expose a local OpenAI-compatible API at:</p><pre tabindex=0><code>http://127.0.0.1:8080
</code></pre><p>Congratulations! If you’ve chosen the Falcon H1R model, you have now successfully served it on your laptop and it’s ready to use. Next, let’s look at integrating the model into OpenWebUI for chatting.</p><h2 id=integrating-with-openwebui>Integrating with OpenwebUI<a hidden class=anchor aria-hidden=true href=#integrating-with-openwebui>#</a></h2><p>Once your selected serving framework is running, the next step is to connect Falcon-H1 to Open WebUI, giving you a simple chat-based interface for interacting with the model.</p><h3 id=starting-open-webui>Starting Open WebUI<a hidden class=anchor aria-hidden=true href=#starting-open-webui>#</a></h3><p>First, let&rsquo;s proceed with installing open-webui cli. Use the command below to install:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>pip install open-webui
</span></span></code></pre></div><blockquote><p><strong>Note:</strong> You should install open-webui cli within your existing conda virtual environment. If you are using MLX to serve local llm and already have a conda environment set up, install open-webui cli in that same one. Then activate your environment to proceed.</p></blockquote><p>After successful installation, let&rsquo;s launch the server.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>open-webui serve
</span></span></code></pre></div><ul><li>Default access: <a href=http://localhost:8080>http://localhost:8080</a></li><li>Custom port:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>open-webui serve --port <span class=m>3000</span> --host 0.0.0.0
</span></span></code></pre></div><h3 id=connecting-llamacpp-to-open-webui>Connecting llama.cpp to Open WebUI<a hidden class=anchor aria-hidden=true href=#connecting-llamacpp-to-open-webui>#</a></h3><ol><li>Open <strong>Open WebUI</strong> in your browser.</li><li>Navigate to <strong>Admin Settings → Connections → OpenAI</strong>.</li><li>Click <strong>Add Connection</strong>.</li><li>Under <strong>Standard / Compatible</strong> (if tabs are visible), configure the following:<ul><li><strong>URL:</strong> <code>http://127.0.0.1:8080/v1</code>.</li><li><strong>API Key:</strong> Leave blank or enter a specific key if configured.</li></ul></li></ol><p>Once the connection is saved, Open WebUI will use your local <strong>llama.cpp</strong> server or <strong>mlx</strong> server as its backend.</p><p>Alright, let’s head back to the main screen and try out a few questions to test the model’s intelligence.</p><img src=./images/instruct-demo.png alt=falcon-h1-instruct style="width:100%;height:auto;border-radius:8px;box-shadow:0 4px 6px rgba(0,0,0,.1);display:block;margin:1.5em 0"><p>Congratulations — you now have your very own chatbot powered by the Falcon models running right on your laptop.</p><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>This guide has outlined the process of deploying Falcon-H1 locally using either the MLX framework for macOS-optimized workflows or the llama.cpp framework for GGUF model formats, along with integrating the chosen backend into Open WebUI to provide an interactive chat interface. The topics covered include minimum system requirements, environment setup, downloading model weights, server configuration, integration steps, and key considerations before deployment.</p><p>Following these steps allows Falcon-H1 to be deployed in a way that matches your hardware capabilities and performance goals, ensuring both efficiency and ease of use. The MLX framework delivers smooth integration with Apple’s hardware ecosystem, while llama.cpp offers portability and compatibility with GGUF models, giving you flexible options for various AI applications.</p><p>For additional experimentation, you can explore other Falcon-H1 variants available on Hugging Face, apply performance optimizations, or incorporate the model into custom workflows and interfaces. With the right setup, Falcon-H1 can be a powerful and versatile asset in your local AI development environment.</p><div class=post-contributors><div class=contributors-section><h4>Contributors</h4><div class=contributors-grid><div class=contributor><img src=https://falcon-lm.github.io/img/contributors/FalconLLM.webp alt="Falcon LLM team" class=contributor-image><p class=contributor-name>Falcon LLM team</p></div></div></div></div></div></article></main><footer class=footer><span>&copy; 2026 <a href=https://falcon-lm.github.io/>Falcon</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a>
</span><span><a href=https://falconllm.tii.ae/falcon-terms-and-conditions.html rel="noopener noreferrer" target=_blank>| Terms and Conditions</a>
</span><span><a href=https://www.tii.ae/privacy-policy rel="noopener noreferrer" target=_blank>| Privacy Policy</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 8" fill="currentcolor"><path d="M12 8H0l6-8z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")},mybutton.oncontextmenu=e=>{e.preventDefault(),document.querySelectorAll(".example-container").forEach(e=>{e.style.backgroundColor="unset"}),document.querySelectorAll(".example-content").forEach(e=>{e.style.display="block",e.style.backgroundColor="var(--code-bg)",e.style.marginBottom="var(--modal-gap)"}),document.querySelectorAll(".next-button").forEach(e=>{e.style.display="none"})}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>